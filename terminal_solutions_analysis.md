# 解决无法指定回到运行交互模式终端的技术方案

## 问题描述
当前热键(Ctrl+;)无法精确识别并回到正在运行TC交互模式的终端窗口，可能切换到错误的终端。

## 方案设计

### 方案1：进程检测方案 (推荐) ⭐⭐⭐⭐⭐
**核心思路**：通过检测终端窗口中运行的进程来识别哪个终端正在运行TC交互模式

**实现方式**：
1. 获取所有终端窗口
2. 对每个终端窗口，检查其关联的进程
3. 查找是否有python进程运行main_enhanced.py
4. 优先切换到正在运行TC交互模式的终端

**优点**：
- 精确度高，能准确识别运行TC的终端
- 实现相对简单，基于系统API
- 不需要额外的文件或网络通信
- 支持多个TC实例同时运行

**缺点**：
- 需要系统权限获取进程信息
- 进程检测可能有一定延迟
- 依赖平台特定的进程查询API

### 方案2：PID文件标记方案 ⭐⭐⭐⭐
**核心思路**：通过PID文件记录TC交互模式实例和对应的终端窗口ID

**实现方式**：
1. TC启动时创建PID文件，记录进程ID和终端窗口ID
2. 热键触发时读取PID文件，检查进程是否还活着
3. 如果进程存在，切换到对应的终端窗口
4. 进程退出时清理PID文件

**优点**：
- 实现简单，跨平台兼容性好
- 性能好，文件读取速度快
- 支持多实例（多个PID文件）

**缺点**：
- 需要维护PID文件的生命周期
- 如果进程异常退出，可能产生僵尸PID文件
- 文件系统权限问题

### 方案3：Socket通信方案 ⭐⭐⭐
**核心思路**：通过Unix socket建立热键处理器与TC交互模式实例的通信

**实现方式**：
1. TC交互模式启动时创建唯一的socket文件
2. 在socket中包含终端窗口ID信息
3. 热键触发时查询所有TC socket，找到活跃的交互模式实例
4. 切换到对应的终端窗口

**优点**：
- 实时性好，能立即检测实例状态
- 支持双向通信，可扩展更多功能
- 可以传递更多上下文信息

**缺点**：
- 实现复杂度较高
- 需要处理socket清理和异常情况
- 可能存在权限和并发问题

### 方案4：窗口标题标记方案 ⭐⭐
**核心思路**：在运行TC交互模式时修改终端窗口标题加入特殊标记

**实现方式**：
1. TC进入交互模式时设置终端标题为特殊格式（如"TC-Interactive-[PID]"）
2. 热键触发时搜索包含TC交互标记的窗口标题
3. 切换到匹配的终端窗口
4. 退出时恢复原始标题

**优点**：
- 实现简单，易于调试
- 用户可见，便于识别
- 跨平台兼容性好

**缺点**：
- 用户可能不希望窗口标题被修改
- 标题修改可能失败或被其他程序覆盖
- 不够可靠，容易被干扰

### 方案5：环境变量方案 ⭐⭐
**核心思路**：通过环境变量标记当前shell session正在运行TC

**实现方式**：
1. TC启动时设置特殊环境变量（如TC_INTERACTIVE_SESSION）
2. 通过检查各终端进程的环境变量来识别TC会话
3. 切换到运行TC的终端

**优点**：
- 实现简单
- 环境变量隔离性好

**缺点**：
- 环境变量可能被子进程继承，导致误判
- 检查进程环境变量需要特殊权限
- 不够精确

## 性能对比

| 方案 | 检测速度 | 准确性 | 实现复杂度 | 资源消耗 |
|------|----------|--------|------------|----------|
| 进程检测 | 中等 | 高 | 中等 | 低 |
| PID文件 | 快 | 高 | 低 | 极低 |
| Socket通信 | 快 | 极高 | 高 | 中等 |
| 窗口标题 | 快 | 中等 | 极低 | 极低 |
| 环境变量 | 慢 | 低 | 低 | 低 |

## 推荐实施策略

**主推方案**：方案1（进程检测）+ 方案2（PID文件）组合
- 优先使用进程检测方式，准确度高
- PID文件作为快速预筛选机制
- 两种方案互相验证，提高可靠性

**实施步骤**：
1. 先实现PID文件方案，快速解决主要问题
2. 逐步添加进程检测功能，提高准确性
3. 添加异常处理和清理机制
4. 性能测试和优化
